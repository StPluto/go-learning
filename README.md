# Go-Learning
Небольшая сумма пройденного в [Go Tour](https://go.dev/tour)
## 1. Using the tour

### Welcome

## 2. Basics

### Packages, variables, and functions

#### Packages

Каждая программа состоит из пакетов. 
Если написанная программа не является пакетом, (т.е является исполняемым файлом) который можно использовать в других проектах, то в начале файла используется алиас "package "main"", иначе "package "INSERT PACKAGE NAME"".

#### Imports, Exported names

Импортирование сторонних библиотек в коде вызывается алиасом import

`import "fmt"
import "math"`

Также библиотеки можно передать в одной строке

`import (
	"fmt"
	"math"
)`

#### Functions, Functions continued, Multiple Results, Named return values

Функции могут не принимать аргументов или принимать несколько аргументов

```
func add(x int, y int) int {
	return x + y
}
```

Где: 

`func` - алиас для вызова функции

`add` - имя функции

`x int, y int` - принимаемы аргументы

`return` - алиас для возврашения результата функции

Также возможно объединенноё объявление переменных

Это - `x int, y int` >>> превратится в это - `x, y int`

Функция может возвращать несколько значений.

`return x,y`

Также возможно "naked" возвращение, способ при котором функция возвращает прописанные при определении переменные.

```
func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
}
```
Где: 

`x, y int` это возвращаемые значения.

#### Variables, Variables with initializers, Short variable declarations

Объявление переменных также возможно с помощью алиаса `var`

`var` может быть использован как на уровне функций, так и на уровне пакета.

`var` может принимать инициализатор (значение), один на каждуй переменную

`var i, j int = 1, 2`

Переменную также можно объявить через алиас `:=`, в таком виде переменную можно объявить только внутри функции

#### Basic types, Zero values, Type conversions, Type inference

В Golang есть базовые типы данных:

`bool` -  Логический тип данных, принимает значения `true` или `false`

`string` - Строковый тип данных, представляет последовательность символов UTF-8

`int int8 int16 int32 int64` Целочисленный тип со знаком, размер зависит от платформы (32 или 64 бита)

`uint uint8 uint16 uint32 uint64` Беззнаковое целое число, размер зависит от платформы (32 или 64 бита)

`uintptr` Целочисленный тип для хранения указателей (для низкоуровневых операций)

`byte` Псевдоним для `uint8`, представляет байт

`rune` Псевдоним для `int32`, представляет код символа Unicode

`float32 float64` 32-битное (одинарная точность) и 64-битное (двойная точность) число с плавающей точкой

`complex64 complex128` Комплексное число с float32 и комплексное число с float64 вещественной и мнимой частями

У переменных есть "нулевые" значения

`0` для числовых типов, `false`для логических типов, и `""` (пустая строка) для строк

Преобразование типов (изменения одного типа переменной в другой) происходит через алиас вида.

`int()` , `float32()` и т.д

Если при объявления переменной не указан тип значения, то переменной будет присвоен тип данных который больше всего подходит этому значению.

#### Constants, Numeric Constants

Константы - это переменные которые не могут быть изменены, для объявление константы используется алиас `const`

`const Pi = 3.14`

### Flow control statements: for, if, else, switch and defer

#### For, For continued, For is Go's "while", Forever.

В Golang существует только один цикл это - `for`

`for` - состоит из трех состовляющих, разделенными точкой с запятой

```
for i := 0; i < 10; i++ {
		sum += i
	}
```

init - выражение выполняющееся в самом начале, выполняется перед первой итерацией единожды, обычно это объявление переменной, которая будет доступна только внутри цикла.

condition (условие) - логическое выражение проверяемое после каждой итерации, цикл будет продолжаться пока выражение является истинным, или выражение внутри станет ложным.

post - выражение выполняется после каждой итерации.

Части init и post, опциональны

```
for ; sum < 1000; {
		sum += sum
	}
```

Также можно удалить точки с запятой и получится Golang вариант цикла `while` 

```
	for sum < 1000 {
		sum += sum
	}
```

Если удалить условие, то можно получить бесконечный цикл

```
for {
	}
```

#### If, If with a short statement, If and else

В Golang условия `if` похожи на цикл `for`, условие не обязательно закрывать в скобки (), но фигурные скобки для выбранных выражений необходимы.

```
if x < 0 {
		return sqrt(-x) + "i"
	}
```

Также как в цикле `for`, в `if` можно выполнить начальную инициализацию, условие будет после точки с запятой, все переменные объявленные таким образом будут видны только внутри условия `if`. 

```
if v := math.Pow(x, n); v < lim {
		return v
	}
```

Переменные объявленные при инициализации условия `if` также будут доступны в условии `else`

```
if v := math.Pow(x, n); v < lim {
		return v
	} else {
		fmt.Printf("%g >= %g\n", v, lim)
	}
	// can't use v here, though
	return lim
```

#### Switch, Switch evaluation order, Switch with no condition

Также в Golang существует конструкция `switch`, элегантный вариант написания нескольких условий `if-else`, в отличии от других языков `switch` в Golang, выполняет первый подходящий `case`, т.к ставит в конце каждого `case` конструкцию `break` автоматически.


### (???) Another important difference is that Go's switch cases need not be constants, and the values involved need not be integers. (???)


В конструкции `switch` кейсы выполняются сверху вних, останавливаясь когда достигнут правильный кейс.

`switch` без условия эквивалентен `switch True`, это удобно когда нужно написать длинные цепи `if-then-else `

#### Defer, Stacking defers

Конструкция `defer`, откладывает выполнение какого-то кода, пока функция в которой он находится не вернет результат.

`defer` выполняется сразу, но вызов резудьтат происходит только после возврата функции в которой он находится.

```
func main() {
	defer fmt.Println("world")

	fmt.Println("hello")
}
```

Сложенные `defer` - это функции выполненные несколько раз. Складываются они в очередь, и после возвращения функцией выполняются в обратном порядке.

```
func main() {
	fmt.Println("counting")

	for i := 0; i < 10; i++ {
		defer fmt.Println(i)
	}

	fmt.Println("done")
}
```

Результат:

```
counting
done
9
8
7
6
5
4
3
2
1
0
```


### More types: structs, slices, and maps.

#### Pointers

В Golang есть Указатели. Указатели содержат адрес значения в памяти

Тип `*T` это указатель в памяти на значение `T`
The type *T is a pointer to a T value. Its zero value is nil.
