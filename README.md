# Go-Learning
Небольшая сумма пройденного в [Go Tour](https://go.dev/tour)
TODO List:
Изучить что такое 'Literal'

## 1. Using the tour

### Welcome

## 2. Basics

### Packages, variables, and functions

#### Packages

Каждая программа состоит из пакетов. 
Если написанная программа не является пакетом, (т.е является исполняемым файлом) который можно использовать в других проектах, то в начале файла используется алиас "package "main"", иначе "package "INSERT PACKAGE NAME"".

#### Imports, Exported names

Импортирование сторонних библиотек в коде вызывается алиасом import

`import "fmt"
import "math"`

Также библиотеки можно передать в одной строке

`import (
	"fmt"
	"math"
)`

#### Functions, Functions continued, Multiple Results, Named return values

Функции могут не принимать аргументов или принимать несколько аргументов

```
func add(x int, y int) int {
	return x + y
}
```

Где: 

`func` - алиас для вызова функции

`add` - имя функции

`x int, y int` - принимаемы аргументы

`return` - алиас для возврашения результата функции

Также возможно объединенноё объявление переменных

Это - `x int, y int` >>> превратится в это - `x, y int`

Функция может возвращать несколько значений.

`return x,y`

Также возможно "naked" возвращение, способ при котором функция возвращает прописанные при определении переменные.

```
func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
}
```
Где: 

`x, y int` это возвращаемые значения.

#### Variables, Variables with initializers, Short variable declarations

Объявление переменных также возможно с помощью алиаса `var`

`var` может быть использован как на уровне функций, так и на уровне пакета.

`var` может принимать инициализатор (значение), один на каждуй переменную

`var i, j int = 1, 2`

Переменную также можно объявить через алиас `:=`, в таком виде переменную можно объявить только внутри функции

#### Basic types, Zero values, Type conversions, Type inference

В Golang есть базовые типы данных:

`bool` -  Логический тип данных, принимает значения `true` или `false`

`string` - Строковый тип данных, представляет последовательность символов UTF-8

`int int8 int16 int32 int64` Целочисленный тип со знаком, размер зависит от платформы (32 или 64 бита)

`uint uint8 uint16 uint32 uint64` Беззнаковое целое число, размер зависит от платформы (32 или 64 бита)

`uintptr` Целочисленный тип для хранения указателей (для низкоуровневых операций)

`byte` Псевдоним для `uint8`, представляет байт

`rune` Псевдоним для `int32`, представляет код символа Unicode

`float32 float64` 32-битное (одинарная точность) и 64-битное (двойная точность) число с плавающей точкой

`complex64 complex128` Комплексное число с float32 и комплексное число с float64 вещественной и мнимой частями

У переменных есть "нулевые" значения

`0` для числовых типов, `false`для логических типов, и `""` (пустая строка) для строк

Преобразование типов (изменения одного типа переменной в другой) происходит через алиас вида.

`int()` , `float32()` и т.д

Если при объявления переменной не указан тип значения, то переменной будет присвоен тип данных который больше всего подходит этому значению.

#### Constants, Numeric Constants

Константы - это переменные которые не могут быть изменены, для объявление константы используется алиас `const`

`const Pi = 3.14`

### Flow control statements: for, if, else, switch and defer

#### For, For continued, For is Go's "while", Forever.

В Golang существует только один цикл это - `for`

`for` - состоит из трех состовляющих, разделенными точкой с запятой

```
for i := 0; i < 10; i++ {
	sum += i
}
```

init - выражение выполняющееся в самом начале, выполняется перед первой итерацией единожды, обычно это объявление переменной, которая будет доступна только внутри цикла.

condition (условие) - логическое выражение проверяемое после каждой итерации, цикл будет продолжаться пока выражение является истинным, или выражение внутри станет ложным.

post - выражение выполняется после каждой итерации.

Части init и post, опциональны

```
for ; sum < 1000; {
	sum += sum
}
```

Также можно удалить точки с запятой и получится Golang вариант цикла `while` 

```
for sum < 1000 {
	sum += sum
}
```

Если удалить условие, то можно получить бесконечный цикл

```
for {
	}
```

#### If, If with a short statement, If and else

В Golang условия `if` похожи на цикл `for`, условие не обязательно закрывать в скобки (), но фигурные скобки для выбранных выражений необходимы.

```
if x < 0 {
		return sqrt(-x) + "i"
	}
```

Также как в цикле `for`, в `if` можно выполнить начальную инициализацию, условие будет после точки с запятой, все переменные объявленные таким образом будут видны только внутри условия `if`. 

```
if v := math.Pow(x, n); v < lim {
		return v
	}
```

Переменные объявленные при инициализации условия `if` также будут доступны в условии `else`

```
if v := math.Pow(x, n); v < lim {
		return v
	} else {
		fmt.Printf("%g >= %g\n", v, lim)
	}
	// can't use v here, though
	return lim
```

#### Switch, Switch evaluation order, Switch with no condition

Также в Golang существует конструкция `switch`, элегантный вариант написания нескольких условий `if-else`, в отличии от других языков `switch` в Golang, выполняет первый подходящий `case`, т.к ставит в конце каждого `case` конструкцию `break` автоматически.


### (???) Another important difference is that Go's switch cases need not be constants, and the values involved need not be integers. (???)


В конструкции `switch` кейсы выполняются сверху вних, останавливаясь когда достигнут правильный кейс.

`switch` без условия эквивалентен `switch True`, это удобно когда нужно написать длинные цепи `if-then-else `

#### Defer, Stacking defers

Конструкция `defer`, откладывает выполнение какого-то кода, пока функция в которой он находится не вернет результат.

`defer` выполняется сразу, но вызов резудьтат происходит только после возврата функции в которой он находится.

```
func main() {
	defer fmt.Println("world")

	fmt.Println("hello")
}
```

Сложенные `defer` - это функции выполненные несколько раз. Складываются они в очередь, и после возвращения функцией выполняются в обратном порядке.

```
func main() {
	fmt.Println("counting")

	for i := 0; i < 10; i++ {
		defer fmt.Println(i)
	}

	fmt.Println("done")
}
```

Результат:

```
counting
done
9
8
7
6
5
4
3
2
1
0
```


### More types: structs, slices, and maps.

#### Pointers

В Golang есть Указатели. Указатели содержат адрес значения в памяти.

Тип `*T` это указатель в памяти на значение `T`. Его нулевое значение это `nil`.

`nil` ≠ 0.

```
var kay = 0

func main(){
	for i := &kay; ; *i++ {
		fmt.Println(*i)
	}
```

Операнд `&` создает указатель на значение переменной `kay`.

Операнд `*` разыменовывает указатель переменной `kay`.

#### Structs, Struct Fields, Pointers to structs, Struct Literals


`struct` - это набор полей.

```
type Vertex struct {
	X int
	Y int
}
```

В блоке выше `type` является алиасом для создания пользовательского типа данных, а `struct` алиас для присвоения типу `Vertex` базового типа `struct`.

Обратиться к полю типа `struct` можно черех точку `.`.

```
func main() {
	v := Vertex{1, 2}
	v.X = 4 // Обращение к Полю X и присваиванию 4 структуры v (Vertex)
	fmt.Println(v.X)
}

```

Также можно обратиться через указатель структуры.

```
func main() {
	v := Vertex{1, 2}
	p := &v
	p.X = 1e9
	fmt.Println(v)
}
```

Поэтому было бы возможно написание `(*p).X`, но код получается слишком громоздким, поэтому Golang разрешает написание `p.X`.

Литерал структуры обозначает новую структуру с перечислением всех его значений.

```
var (
	v1 = Vertex{1, 2}  // has type Vertex
	v2 = Vertex{Y: 2, X: 1}  // Y:0 is implicit
	v3 = Vertex{}      // X:0 and Y:0
	p  = &Vertex{1, 2} // has type *Vertex
)
```

Можно указать подборку переменных через `Name:`.

```
v2 = Vertex{Y: 2, X: 1}  // Y:0 is implicit

func main() {
	fmt.Println( v2)
}
```

Результат.

```
{1 2}
```

#### Arrays

Выражение `[n]T` означает объявление массива `n`- значений, типа `T`.

```
var a [10]int
```

Переменная `a` это массив из 10 элементов типа `int`.
Размер массива не может быть изменён т.к размер это часть его типа.

`slice` (далее срез) же с другой стороны не имеет таких ограничений, может изменять свой размер. На практике срезы гораздо практичнее чем массивы.

Выражений `[]T` обозначает объявление среза элементов типа `T`

Срезы состоят из нижней границы (low bound) и верхней (high bound) разделенными двоиточием.

`a[low : high]`

Этот отрезок включает в себя начиная с первого элемента до последнего не включая его.

Следующее выражение выберет элементы начиная с `1` до `3`.

`a[1:4]`

Срезы не хранят никакую информацию, они только указывают на отрезок из массива. Изменение элемента среза также изменит элемент соответствующего ему массива. Также другие срезы которые ссылаются на этот массив потерпят те же изменения.

Литерал среза это как литерал массива без длины.


Это литерал массива.

```
[3]bool{true, true, false}
```
А это литерал среза, который создает точно такой же массив что выше и после этого ссылается на него.

```
[]bool{true, true, false}
```

При создании среза можно не указывать нижнюю и верхнюю границу, вместо них будет использованы значения по умолчанию, 0 для нижней границы и длина всего среза для верхней границы.

Для массива.

`var a [10]int`

Следующие варианты среза идентичны:
```
a[0:10]
a[:10]
a[0:]
a[:]
```

Срез имеет длину (Length) и вместимость (Capacity).

Под длинной (Length) среза подразумевается число элементов который он содержит.

Вместимостью (Capacity) называют число элементов который содержит *массив* на который он ссылается, начиная с первого элемента среза.

Длина и Вместимость среза можно получить с помощью функций `len(a)` и `cap(a)`.

Нулевое значени для среза это `nil`

`nil` срез имеет длину 0 и не имеет массива.

Срезы также можно создать внутренней функцией `make`, вот так можно создать динамически размеренный массив

`make` функция выделяет нулевой массив и возвращает срез ссылающийся на этот массив

`a := make([]int, 5)  // len(a)=5`

Чтобы обозначить вместимость передайте третий аргумент функции `make`

```
b := make([]int, 0, 5) // len(b)=0, cap(b)=5

b = b[:cap(b)] // len(b)=5, cap(b)=5
b = b[1:]      // len(b)=4, cap(b)=4
```

Срезв могут хранить любой тип данных, включая другие срезы

`board := [][]string`

Добавление элементов в срез очень частая ситуация, Golang позволяет добавлять элементы встроенной функцией `append`.

`func append(s []T, vs ...T) []T`

Первый аргумент `s` это срез к которому будут добавлять элементы, остальные это значения.

Результирующее значение `append` вернет срез с изначальными значениями и ещё добавленными значениями.

Если массив среза мал для добавления значений то будет выделен новый массив.
Возвращенный срез будет обращаться к новому выделенному массиву.